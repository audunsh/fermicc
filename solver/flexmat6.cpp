#include "flexmat6.h"
#define ARMA_64BIT_WORD
#include <armadillo>
#include "solver/unpack_sp_mat.h"

using namespace std;
using namespace arma;


flexmat6::flexmat6()
{
}

void flexmat6::init(vec values, uvec p, uvec q, uvec r, uvec s, uvec t, uvec u, int Np, int Nq, int Nr, int Ns, int Nt, int Nu){
    iNp = Np;
    iNq = Nq;
    iNr = Nr;
    iNs = Ns;
    iNt = Nt;
    iNu = Nu;

    vValues = values;
    vp = p;
    vq = q;
    vr = r;
    vs = s;
    vt = t;
    vu = u;

    cols_i = conv_to<uvec>::from(vs + vt*iNs + vu*iNs*iNt);
    rows_i = conv_to<uvec>::from(vp + vq*iNp + vr*iNp*iNq);

    int sz = iNs*iNt*iNu; //number of columns in total
    col_ptrs.set_size(sz); //used in mapping
    for(uint i = 0; i<sz; ++i){
        col_ptrs(i) = -1;
    }
}

void flexmat6::map_indices(){
    //map out which indices correspond to which rows
    uvec cols = conv_to<uvec>::from(vs + vt*iNs + vu*iNs*iNt);
    uvec rows = conv_to<uvec>::from(vp + vq*iNp + vr*iNp*iNq);

    row_lengths = conv_to<uvec>::from(zeros(iNp*iNq*iNr));
    row_indices.set_size(iNp*iNq*iNr);
    col_lengths = conv_to<uvec>::from(zeros(iNs*iNt*iNu));
    col_indices.set_size(iNs*iNt*iNu);
    uint i_max = vValues.size();

    for(uint i = 0; i<i_max;++i){
        row_lengths(rows(i)) += 1;
        col_lengths(cols(i)) += 1;
    }
    i_max = iNp*iNq*iNr; //number of rows
    uint j, j_max;
    for(uint i = 0; i < i_max; ++i){
        //j_max = row_lengths(i);
        row_indices(i).set_size(row_lengths(i));
    }
    i_max = iNs*iNt*iNu; //number of cols
    for(uint i = 0; i < i_max; ++i){
        //j_max = row_lengths(i);
        col_indices(i).set_size(col_lengths(i));
    }


    uvec row_count = conv_to<uvec>::from(zeros(iNp*iNq*iNr));
    uvec col_count = conv_to<uvec>::from(zeros(iNs*iNt*iNu));

    i_max = vValues.size();
    uint ri, ci; //row i and col i
    for(uint i = 0; i<i_max;++i){
        ri = rows(i);
        ci = cols(i);

        row_indices(ri)(row_count(ri)) = i;
        col_indices(ci)(col_count(ci)) = i;
        row_count(ri) += 1;
        col_count(ci) += 1;

    }

    //it should now be possible to get a vector of all elements in a given row or column i by calling
    //   row_indices(i)
    //   col_indices(i)
}

void flexmat6::partition(field<vec> fBlocks){
    //partition the COO indices into blocks according to fBlocks (generated by initializer)
    //not yet implemented
    uint nblocks = fBlocks.size(); //number of blocks
}


mat flexmat6::rows_dense(uvec urows){
    //returns a dense matrix with the rows (truncated in the columns containing zeros)
    //First row contains column indices in the full matrix
    //identify unique columns

    //1. find longest row
    uint blocksize = 0; //number of columns in block
    uint n_cols = 0; //total number of column indices
    for(uint i = 0; i<urows.size(); ++i){
        n_cols += row_lengths(urows(i));
        //cout << "Updating blocksize:" << row_lengths(urows(i)) << endl;
        if(row_lengths(urows(i))>blocksize){

            blocksize = row_lengths(urows(i));
        }
    }



    //2. set up M(rows.size()+1, longest row)
    MCols.clear();
    MCols.set_size(blocksize);


    //ivec MCols(blocksize);
    for(uint i = 0; i < blocksize; ++i){
        MCols(i) = -1;
    }

    //find all unique column indices
    all_columns.clear();
    all_columns.set_size(n_cols);
    uint c = 0; //counter
    //uint elements_in_current_row;
    uint current_col, current_row, current_ind;
    for(uint i = 0; i < urows.size(); ++i){
        current_row = urows(i);
        //element_in_row = row_lengths(current_row);
        for(uint j = 0; j< row_lengths(current_row); ++j){
            current_ind = row_indices(current_row)(j); //index to element in COO rep.
            all_columns(c) = cols_i(current_ind);
            c+=1;
        }
    }
    MCols = unique(all_columns);

    //map all unique indices in col_ptrs
    for(uint i = 0; i < MCols.size(); ++i){
        col_ptrs(MCols(i)) = i;
        //now: col_ptrs(current_col) is the index of the current dense block
        //this makes it possible to cast all elements to a dense matrix, and afterwards cast them back
    }



    //3. assign M(0, :) = unique indices

    //Cast all elements to a dense matrix
    mat M(urows.size(), blocksize);
    //mat M;
    //M.randn(urows.size(), blocksize);
    //cout << urows.size() << " " << blocksize << " " << n_cols << endl;


    uint found = 0;

    for(uint i = 0; i < urows.size(); ++i){
        current_row = urows(i);
        for(uint j = 0; j< row_lengths(current_row); ++j){
            current_ind = row_indices(current_row)(j); //index to element in COO rep.
            current_col = cols_i(current_ind);
            M(i, col_ptrs(current_col)) = vValues(current_ind);
            //M(i,  0) = 0; //vValues(current_ind); //Why does this line cause a segmentation fault?!
        }
    }


    //reset col_ptrs for next block
    for(uint i = 0; i < MCols.size(); ++i){
        col_ptrs(MCols(i)) = -1;
    }


    return M;
}

void flexmat6::set_amplitudes(vec Energy){


    vEnergy = Energy;
    vec vEa = vEnergy.elem(vp + iNs);
    vec vEb = vEnergy.elem(vq + iNs);
    vec vEc = vEnergy.elem(vr + iNs);

    vec vEi = vEnergy.elem(vs);
    vec vEj = vEnergy.elem(vt);
    vec vEk = vEnergy.elem(vu);

    vValues = vValues/(vEi + vEj + vEk - vEa - vEb - vEc);

    uvec nnz = find(vValues!= 0);
    //cout << nnz.size() << " " << vValues.size() << endl;
    vp = vp.elem(nnz);
    vq = vq.elem(nnz);
    vr = vr.elem(nnz);
    vs = vs.elem(nnz);
    vValues = vValues.elem(nnz);
}

void flexmat6::shed_zeros(){
    //retain only nonzero elements
    uvec nnz = find(vValues!= 0);
    //cout << nnz.size() << " " << vValues.size() << endl;
    vp = vp.elem(nnz);
    vq = vq.elem(nnz);
    vr = vr.elem(nnz);
    vs = vs.elem(nnz);
    vValues = vValues.elem(nnz);

    cols_i = conv_to<uvec>::from(vs + vt*iNs + vu*iNs*iNt);
    rows_i = conv_to<uvec>::from(vp + vq*iNp + vr*iNp*iNq);

    int sz = iNs*iNt*iNu; //number of columns in total
    col_ptrs.set_size(sz); //used in mapping
    for(uint i = 0; i<sz; ++i){
        col_ptrs(i) = -1;
    }
}


